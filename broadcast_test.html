<!DOCTYPE html>
<html>
<head>
    <title>P2P Video Broadcast - GitHub Pages</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a2980, #26d0ce);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .mode-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        .mode-card {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .mode-card:hover {
            transform: translateY(-5px);
            border-color: #3498db;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        .mode-card.active {
            border-color: #2ecc71;
            background: #f0fff4;
        }
        .mode-card h3 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .mode-card p {
            color: #666;
            font-size: 14px;
            line-height: 1.5;
        }
        .setup {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 25px;
            border: 2px solid #e9ecef;
        }
        .input-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
        }
        input, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 16px;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #3498db;
        }
        button {
            background: #2ecc71;
            color: white;
            border: none;
            padding: 14px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
            margin: 5px;
        }
        button:hover {
            background: #27ae60;
        }
        button.secondary {
            background: #3498db;
        }
        button.secondary:hover {
            background: #2980b9;
        }
        button.danger {
            background: #e74c3c;
        }
        button.danger:hover {
            background: #c0392b;
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        .status.good {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .video-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .video-box {
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        .video-box video {
            width: 100%;
            height: 225px;
            background: #000;
            display: block;
        }
        .video-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            font-size: 14px;
        }
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }
        .viewer-count {
            display: inline-block;
            background: #3498db;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            margin-left: 10px;
        }
        .hidden {
            display: none;
        }
        .info-box {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid #b6e0fe;
        }
    </style>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.5/dist/peerjs.min.js"></script>

</head>
<body>
    <div class="container">
        <h1>üé• P2P Video Broadcast</h1>
        
        <div id="setupSection">
            <div class="info-box">
                <h3>How It Works:</h3>
                <p>This is a peer-to-peer video streaming platform. One broadcaster can stream to multiple viewers using WebRTC. Works on GitHub Pages!</p>
            </div>
            
            <div class="mode-selector">
                <div class="mode-card" onclick="selectMode('broadcaster')">
                    <h3>üé§ Broadcaster</h3>
                    <p>Stream your camera to multiple viewers. You need to share the Room ID.</p>
                </div>
                <div class="mode-card" onclick="selectMode('viewer')">
                    <h3>üëÅÔ∏è Viewer</h3>
                    <p>Watch a broadcaster's stream. You'll need the Room ID.</p>
                </div>
                <div class="mode-card" onclick="selectMode('mesh')">
                    <h3>üîÄ Mesh Network</h3>
                    <p>Everyone can broadcast and watch each other (experimental).</p>
                </div>
            </div>
            
            <div class="setup">
                <div class="input-group">
                    <label for="username">Your Name</label>
                    <input type="text" id="username" placeholder="Enter your name" value="Broadcaster">
                </div>
                
                <div id="broadcasterConfig">
                    <div class="input-group">
                        <label>Camera Quality</label>
                        <select id="cameraQuality">
                            <option value="low">Low (320x240) - Fastest</option>
                            <option value="medium" selected>Medium (640x480) - Balanced</option>
                            <option value="high">High (1280x720) - Best Quality</option>
                        </select>
                    </div>
                    <button onclick="createBroadcastRoom()">Create Broadcast Room</button>
                </div>
                
                <div id="viewerConfig" class="hidden">
                    <div class="input-group">
                        <label for="roomIdInput">Room ID to Join</label>
                        <input type="text" id="roomIdInput" placeholder="Enter Room ID from broadcaster">
                    </div>
                    <button onclick="joinAsViewer()" class="secondary">Join as Viewer</button>
                </div>
                
                <div id="meshConfig" class="hidden">
                    <div class="input-group">
                        <label for="meshRoomId">Mesh Room ID</label>
                        <input type="text" id="meshRoomId" placeholder="Enter mesh room name" value="mesh-room">
                    </div>
                    <button onclick="joinMeshRoom()">Join Mesh Network</button>
                </div>
            </div>
            
            <div id="roomInfo" class="hidden">
                <div class="status good" id="roomStatus">
                    Room created successfully!
                </div>
                
                <div class="input-group">
                    <label>Room ID (Share this with viewers)</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="roomIdDisplay" readonly style="background: #f8f9fa; font-family: monospace;">
                        <button onclick="copyRoomId()" class="secondary">Copy</button>
                    </div>
                </div>
                
                <div id="broadcasterInfo" class="hidden">
                    <div class="input-group">
                        <label>Viewer Count</label>
                        <div id="viewerCount" class="viewer-count">0 viewers</div>
                    </div>
                    <button onclick="startBroadcasting()">Start Broadcasting</button>
                </div>
                
                <div id="viewerInfo" class="hidden">
                    <button onclick="startWatching()">Start Watching</button>
                </div>
            </div>
        </div>
        
        <div id="broadcastSection" class="hidden">
            <div class="status good" id="broadcastStatus">
                Ready to broadcast
            </div>
            
            <div class="video-container" id="videoContainer">
                <!-- Videos will be added here -->
            </div>
            
            <div class="controls">
                <button onclick="toggleCamera()" id="cameraBtn">üé• Turn Camera Off</button>
                <button onclick="toggleMic()" id="micBtn">üé§ Mute Mic</button>
                <button onclick="toggleScreenShare()" id="screenBtn" class="secondary">üñ•Ô∏è Share Screen</button>
                <button onclick="endBroadcast()" class="danger">Stop Broadcast</button>
            </div>
            
            <div id="viewerControls" class="hidden">
                <button onclick="requestSpeak()" class="secondary">‚úã Request to Speak</button>
                <button onclick="leaveViewer()" class="danger">Leave Stream</button>
            </div>
        </div>
    </div>
   
    <script>
        // P2P Video Broadcast Application
        class VideoBroadcast {
            constructor() {
                this.mode = null;
                this.username = 'Broadcaster';
                this.roomId = null;
                this.peer = null;
                this.connections = new Map();
                this.localStream = null;
                this.screenStream = null;
                this.isBroadcasting = false;
                this.isCameraOn = true;
                this.isMicOn = true;
                this.isScreenSharing = false;
                this.viewerCount = 0;
                
                // Different STUN/TURN servers for better connectivity
                this.iceServers = [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' },
                    // Public TURN servers (may have limits)
                    {
                        urls: 'turn:openrelay.metered.ca:80',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelay.metered.ca:443',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    }
                ];
                
                this.init();
            }
            
            init() {
                // Load saved username
                const saved = localStorage.getItem('videoChat_username');
                if (saved) {
                    document.getElementById('username').value = saved;
                }
            }
            
            selectMode(mode) {
                this.mode = mode;
                
                // Update UI
                document.querySelectorAll('.mode-card').forEach(card => {
                    card.classList.remove('active');
                });
                event.target.closest('.mode-card').classList.add('active');
                
                // Show appropriate config
                document.getElementById('broadcasterConfig').classList.add('hidden');
                document.getElementById('viewerConfig').classList.add('hidden');
                document.getElementById('meshConfig').classList.add('hidden');
                
                if (mode === 'broadcaster') {
                    document.getElementById('broadcasterConfig').classList.remove('hidden');
                } else if (mode === 'viewer') {
                    document.getElementById('viewerConfig').classList.remove('hidden');
                } else if (mode === 'mesh') {
                    document.getElementById('meshConfig').classList.remove('hidden');
                }
                
                console.log(`Selected mode: ${mode}`);
            }
            
            async createBroadcastRoom() {
                this.username = document.getElementById('username').value || 'Broadcaster';
                localStorage.setItem('videoChat_username', this.username);
                this.mode = 'broadcaster';
                
                // Generate room ID
                this.roomId = this.generateRoomId();
                
                await this.initializePeer();
                if (!this.peer) return;
                
                // Get camera access
                try {
                    await this.getUserMedia();
                } catch (error) {
                    alert('Camera access required for broadcasting');
                    return;
                }
                
                // Show room info
                this.showRoomInfo();
                document.getElementById('broadcasterInfo').classList.remove('hidden');
                this.updateStatus(`Room created: ${this.roomId}`);
            }
            
            async joinAsViewer() {
                this.username = document.getElementById('username').value || 'Viewer';
                localStorage.setItem('videoChat_username', this.username);
                this.mode = 'viewer';
                
                this.roomId = document.getElementById('roomIdInput').value.trim();
                if (!this.roomId) {
                    alert('Please enter a Room ID');
                    return;
                }
                
                await this.initializePeer();
                if (!this.peer) return;
                
                // Show room info
                this.showRoomInfo();
                document.getElementById('viewerInfo').classList.remove('hidden');
                this.updateStatus(`Joining room: ${this.roomId}`);
                
                // Connect to broadcaster
                this.connectToPeer(this.roomId);
            }
            
            async joinMeshRoom() {
                this.username = document.getElementById('username').value || 'User';
                localStorage.setItem('videoChat_username', this.username);
                this.mode = 'mesh';
                
                this.roomId = document.getElementById('meshRoomId').value.trim() || 'mesh-room';
                
                await this.initializePeer();
                if (!this.peer) return;
                
                // Get camera for mesh mode
                try {
                    await this.getUserMedia();
                } catch (error) {
                    console.log('Camera not available for mesh mode');
                }
                
                // Show room info
                this.showRoomInfo();
                this.updateStatus(`Joined mesh network: ${this.roomId}`);
                
                // In mesh mode, we'll discover peers through signaling
                // For simplicity, we'll use the room ID as discovery channel
            }
            
            async initializePeer() {
                try {
                    // Use a public signaling server (PeerJS)
                    // Note: These servers may have limitations
                    this.peer = new Peer({
                        host: 'peerjs-server1.herokuapp.com',
                        port: 443,
                        secure: true,
                        path: '/',
                        config: {
                            iceServers: this.iceServers,
                            iceTransportPolicy: 'all',
                            iceCandidatePoolSize: 10
                        },
                        debug: 2
                    });
                    
                    this.peer.on('open', (id) => {
                        console.log('Connected to signaling server with ID:', id);
                        this.updateStatus('Connected to signaling server');
                        
                        if (this.mode === 'broadcaster') {
                            // Broadcaster's peer ID is the room ID
                            // We'll use our generated room ID as the broadcast channel
                        }
                    });
                    
                    this.peer.on('connection', (conn) => {
                        this.handleDataConnection(conn);
                    });
                    
                    this.peer.on('call', (call) => {
                        this.handleVideoCall(call);
                    });
                    
                    this.peer.on('error', (error) => {
                        console.error('PeerJS error:', error);
                        this.updateStatus(`Error: ${error.message}`, 'error');
                    });
                    
                    return true;
                    
                } catch (error) {
                    console.error('Failed to initialize PeerJS:', error);
                    this.updateStatus('Failed to connect to signaling server', 'error');
                    alert('Failed to connect. Please try again or use a different method.');
                    return false;
                }
            }
            
            async getUserMedia() {
                try {
                    const quality = document.getElementById('cameraQuality').value;
                    let constraints = {
                        audio: true,
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            frameRate: { ideal: 24 }
                        }
                    };
                    
                    if (quality === 'low') {
                        constraints.video = { width: { ideal: 320 }, height: { ideal: 240 } };
                    } else if (quality === 'high') {
                        constraints.video = { width: { ideal: 1280 }, height: { ideal: 720 } };
                    }
                    
                    this.localStream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    // Show local video preview
                    this.addVideoStream('local', this.localStream, `${this.username} (You)`);
                    
                    return true;
                } catch (error) {
                    console.error('Failed to get media:', error);
                    this.updateStatus('Camera/mic access denied', 'error');
                    return false;
                }
            }
            
            async getScreenShare() {
                try {
                    this.screenStream = await navigator.mediaDevices.getDisplayMedia({
                        video: true,
                        audio: true
                    });
                    
                    // Show screen share preview
                    this.addVideoStream('screen', this.screenStream, `${this.username} (Screen)`);
                    
                    // Replace video track in all connections
                    this.replaceVideoTrack(this.screenStream.getVideoTracks()[0]);
                    
                    return true;
                } catch (error) {
                    console.error('Failed to get screen share:', error);
                    return false;
                }
            }
            
            connectToPeer(peerId) {
                if (!this.peer) return;
                
                console.log('Connecting to peer:', peerId);
                
                // First establish data connection
                const dataConn = this.peer.connect(peerId, {
                    metadata: {
                        username: this.username,
                        type: this.mode,
                        roomId: this.roomId
                    }
                });
                
                this.setupDataConnection(dataConn, peerId);
            }
            
            handleDataConnection(conn) {
                const peerId = conn.peer;
                const metadata = conn.metadata || {};
                
                console.log('New data connection from:', metadata.username);
                
                this.setupDataConnection(conn, peerId, metadata.username);
                
                // If we're the broadcaster and this is a viewer, call them
                if (this.mode === 'broadcaster' && metadata.type === 'viewer') {
                    setTimeout(() => {
                        this.callPeer(peerId);
                    }, 1000);
                }
                
                // If mesh mode, call each other
                if (this.mode === 'mesh' && this.localStream) {
                    setTimeout(() => {
                        this.callPeer(peerId);
                    }, 1000);
                }
            }
            
            setupDataConnection(conn, peerId, username = 'Unknown') {
                conn.on('open', () => {
                    console.log('Data connection opened with:', username);
                    
                    this.connections.set(peerId, {
                        conn: conn,
                        username: username,
                        call: null,
                        stream: null
                    });
                    
                    this.updateViewerCount();
                    
                    if (this.mode === 'broadcaster') {
                        this.updateStatus(`New viewer: ${username}`);
                    }
                });
                
                conn.on('data', (data) => {
                    this.handleDataMessage(data, peerId);
                });
                
                conn.on('close', () => {
                    console.log('Data connection closed:', peerId);
                    this.handleDisconnection(peerId);
                });
            }
            
            async callPeer(peerId) {
                if (!this.peer || !this.localStream) return;
                
                try {
                    console.log('Calling peer:', peerId);
                    
                    const call = this.peer.call(peerId, this.localStream);
                    
                    call.on('stream', (remoteStream) => {
                        console.log('Received stream from:', peerId);
                        this.addVideoStream(peerId, remoteStream, this.connections.get(peerId)?.username || 'Peer');
                        
                        if (this.connections.has(peerId)) {
                            const connection = this.connections.get(peerId);
                            connection.call = call;
                            connection.stream = remoteStream;
                        }
                    });
                    
                    call.on('close', () => {
                        console.log('Call ended with:', peerId);
                        this.removeVideoStream(peerId);
                    });
                    
                    call.on('error', (error) => {
                        console.error('Call error:', error);
                    });
                    
                } catch (error) {
                    console.error('Failed to call peer:', error);
                }
            }
            
            handleVideoCall(call) {
                const peerId = call.peer;
                console.log('Incoming video call from:', peerId);
                
                if (this.localStream) {
                    // Answer with our stream
                    call.answer(this.localStream);
                } else {
                    // If we don't have a stream (viewer), still answer but send null
                    call.answer();
                }
                
                call.on('stream', (remoteStream) => {
                    console.log('Received video stream from:', peerId);
                    
                    let username = 'Broadcaster';
                    if (this.connections.has(peerId)) {
                        username = this.connections.get(peerId).username;
                    }
                    
                    this.addVideoStream(peerId, remoteStream, username);
                    
                    if (this.connections.has(peerId)) {
                        const connection = this.connections.get(peerId);
                        connection.call = call;
                        connection.stream = remoteStream;
                    }
                });
                
                call.on('close', () => {
                    this.removeVideoStream(peerId);
                });
            }
            
            handleDataMessage(data, peerId) {
                try {
                    if (typeof data === 'string') {
                        const message = JSON.parse(data);
                        
                        switch(message.type) {
                            case 'viewer_joined':
                                this.updateStatus(`Viewer joined: ${message.username}`);
                                break;
                            case 'speak_request':
                                this.handleSpeakRequest(peerId, message);
                                break;
                        }
                    }
                } catch (error) {
                    console.error('Error handling data message:', error);
                }
            }
            
            handleSpeakRequest(peerId, message) {
                if (this.mode === 'broadcaster') {
                    if (confirm(`${message.username} wants to speak. Allow?`)) {
                        // Send approval
                        this.sendToPeer(peerId, {
                            type: 'speak_approved',
                            message: 'You can now speak'
                        });
                    }
                }
            }
            
            sendToPeer(peerId, data) {
                const connection = this.connections.get(peerId);
                if (connection && connection.conn && connection.conn.open) {
                    connection.conn.send(JSON.stringify(data));
                }
            }
            
            broadcastToAll(data) {
                for (const [peerId, connection] of this.connections) {
                    if (connection.conn && connection.conn.open) {
                        connection.conn.send(JSON.stringify(data));
                    }
                }
            }
            
            async startBroadcasting() {
                if (!this.localStream) {
                    alert('Camera access required for broadcasting');
                    return;
                }
                
                this.isBroadcasting = true;
                
                // Show broadcast section
                document.getElementById('setupSection').classList.add('hidden');
                document.getElementById('broadcastSection').classList.remove('hidden');
                document.getElementById('viewerControls').classList.add('hidden');
                
                this.updateStatus('Broadcasting live!', 'good');
                
                // In a real implementation, we would connect to all viewers here
                // For now, we'll rely on the signaling server connections
            }
            
            async startWatching() {
                // Show broadcast section as viewer
                document.getElementById('setupSection').classList.add('hidden');
                document.getElementById('broadcastSection').classList.remove('hidden');
                document.getElementById('viewerControls').classList.remove('hidden');
                
                this.updateStatus('Connected to broadcast', 'good');
                
                // Wait for broadcaster to call us
                this.updateStatus('Waiting for video stream...');
            }
            
            addVideoStream(id, stream, label) {
                // Remove existing video if any
                this.removeVideoStream(id);
                
                const videoContainer = document.getElementById('videoContainer');
                
                const videoBox = document.createElement('div');
                videoBox.className = 'video-box';
                videoBox.id = `video-${id}`;
                
                const video = document.createElement('video');
                video.autoplay = true;
                video.playsInline = true;
                video.muted = (id === 'local' || id === 'screen');
                video.srcObject = stream;
                
                const videoLabel = document.createElement('div');
                videoLabel.className = 'video-label';
                videoLabel.textContent = label;
                
                videoBox.appendChild(video);
                videoBox.appendChild(videoLabel);
                videoContainer.appendChild(videoBox);
                
                // Play the video
                video.play().catch(e => console.log('Video play error:', e));
            }
            
            removeVideoStream(id) {
                const videoElement = document.getElementById(`video-${id}`);
                if (videoElement) {
                    const video = videoElement.querySelector('video');
                    if (video && video.srcObject) {
                        video.srcObject.getTracks().forEach(track => track.stop());
                    }
                    videoElement.remove();
                }
            }
            
            async toggleCamera() {
                if (!this.localStream) return;
                
                this.isCameraOn = !this.isCameraOn;
                const videoTrack = this.localStream.getVideoTracks()[0];
                
                if (videoTrack) {
                    videoTrack.enabled = this.isCameraOn;
                    document.getElementById('cameraBtn').textContent = 
                        this.isCameraOn ? 'üé• Turn Camera Off' : 'üé• Turn Camera On';
                    
                    // Replace track in all active calls
                    this.replaceVideoTrack(this.isCameraOn ? videoTrack : null);
                }
            }
            
            async toggleMic() {
                if (!this.localStream) return;
                
                this.isMicOn = !this.isMicOn;
                const audioTrack = this.localStream.getAudioTracks()[0];
                
                if (audioTrack) {
                    audioTrack.enabled = this.isMicOn;
                    document.getElementById('micBtn').textContent = 
                        this.isMicOn ? 'üé§ Mute Mic' : 'üé§ Unmute Mic';
                    
                    // Replace track in all active calls
                    this.replaceAudioTrack(this.isMicOn ? audioTrack : null);
                }
            }
            
            async toggleScreenShare() {
                if (!this.isScreenSharing) {
                    // Start screen share
                    const success = await this.getScreenShare();
                    if (success) {
                        this.isScreenSharing = true;
                        document.getElementById('screenBtn').textContent = 'üñ•Ô∏è Stop Screen Share';
                    }
                } else {
                    // Stop screen share
                    if (this.screenStream) {
                        this.screenStream.getTracks().forEach(track => track.stop());
                        this.screenStream = null;
                        this.removeVideoStream('screen');
                    }
                    
                    this.isScreenSharing = false;
                    document.getElementById('screenBtn').textContent = 'üñ•Ô∏è Share Screen';
                    
                    // Restore camera if available
                    if (this.localStream) {
                        const videoTrack = this.localStream.getVideoTracks()[0];
                        if (videoTrack) {
                            this.replaceVideoTrack(videoTrack);
                        }
                    }
                }
            }
            
            replaceVideoTrack(newTrack) {
                for (const [peerId, connection] of this.connections) {
                    if (connection.call && connection.call.peerConnection) {
                        const sender = connection.call.peerConnection.getSenders()
                            .find(s => s.track && s.track.kind === 'video');
                        
                        if (sender) {
                            sender.replaceTrack(newTrack);
                        }
                    }
                }
            }
            
            replaceAudioTrack(newTrack) {
                for (const [peerId, connection] of this.connections) {
                    if (connection.call && connection.call.peerConnection) {
                        const sender = connection.call.peerConnection.getSenders()
                            .find(s => s.track && s.track.kind === 'audio');
                        
                        if (sender) {
                            sender.replaceTrack(newTrack);
                        }
                    }
                }
            }
            
            requestSpeak() {
                if (this.mode === 'viewer') {
                    this.broadcastToAll({
                        type: 'speak_request',
                        username: this.username
                    });
                    this.updateStatus('Requested to speak');
                }
            }
            
            updateViewerCount() {
                this.viewerCount = this.connections.size;
                document.getElementById('viewerCount').textContent = 
                    `${this.viewerCount} viewer${this.viewerCount !== 1 ? 's' : ''}`;
            }
            
            handleDisconnection(peerId) {
                if (this.connections.has(peerId)) {
                    const connection = this.connections.get(peerId);
                    this.updateStatus(`${connection.username} disconnected`);
                    this.connections.delete(peerId);
                    this.removeVideoStream(peerId);
                    this.updateViewerCount();
                }
            }
            
            endBroadcast() {
                // Stop all tracks
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                }
                if (this.screenStream) {
                    this.screenStream.getTracks().forEach(track => track.stop());
                }
                
                // Close all connections
                for (const [peerId, connection] of this.connections) {
                    if (connection.call) {
                        connection.call.close();
                    }
                    if (connection.conn) {
                        connection.conn.close();
                    }
                }
                this.connections.clear();
                
                // Destroy peer
                if (this.peer) {
                    this.peer.destroy();
                }
                
                // Reset UI
                this.backToSetup();
                this.updateStatus('Broadcast ended');
            }
            
            leaveViewer() {
                // Stop all streams
                const videoContainer = document.getElementById('videoContainer');
                videoContainer.querySelectorAll('video').forEach(video => {
                    if (video.srcObject) {
                        video.srcObject.getTracks().forEach(track => track.stop());
                    }
                });
                
                // Close connections
                for (const [peerId, connection] of this.connections) {
                    if (connection.call) {
                        connection.call.close();
                    }
                    if (connection.conn) {
                        connection.conn.close();
                    }
                }
                
                if (this.peer) {
                    this.peer.destroy();
                }
                
                this.backToSetup();
                this.updateStatus('Left the stream');
            }
            
            showRoomInfo() {
                document.getElementById('roomIdDisplay').value = this.roomId;
                document.getElementById('roomInfo').classList.remove('hidden');
                document.getElementById('setup').classList.add('hidden');
            }
            
            updateStatus(message, type = 'good') {
                const status = document.getElementById(this.isBroadcasting ? 'broadcastStatus' : 'roomStatus');
                status.textContent = message;
                status.className = `status ${type}`;
            }
            
            generateRoomId() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                let id = '';
                for (let i = 0; i < 6; i++) {
                    id += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return id;
            }
            
            backToSetup() {
                document.getElementById('broadcastSection').classList.add('hidden');
                document.getElementById('setupSection').classList.remove('hidden');
                document.getElementById('roomInfo').classList.add('hidden');
                
                // Clear video container
                document.getElementById('videoContainer').innerHTML = '';
                
                // Reset connections
                this.connections.clear();
                this.viewerCount = 0;
                this.isBroadcasting = false;
            }
        }
        
        // Initialize broadcast
        const broadcast = new VideoBroadcast();
        
        // Global functions
        window.selectMode = (mode) => broadcast.selectMode(mode);
        window.createBroadcastRoom = () => broadcast.createBroadcastRoom();
        window.joinAsViewer = () => broadcast.joinAsViewer();
        window.joinMeshRoom = () => broadcast.joinMeshRoom();
        window.startBroadcasting = () => broadcast.startBroadcasting();
        window.startWatching = () => broadcast.startWatching();
        window.toggleCamera = () => broadcast.toggleCamera();
        window.toggleMic = () => broadcast.toggleMic();
        window.toggleScreenShare = () => broadcast.toggleScreenShare();
        window.requestSpeak = () => broadcast.requestSpeak();
        window.endBroadcast = () => broadcast.endBroadcast();
        window.leaveViewer = () => broadcast.leaveViewer();
        window.copyRoomId = () => {
            const roomId = document.getElementById('roomIdDisplay').value;
            navigator.clipboard.writeText(roomId)
                .then(() => alert('Room ID copied!'))
                .catch(() => prompt('Copy:', roomId));
        };
        
        // Auto-select broadcaster mode
        document.addEventListener('DOMContentLoaded', () => {
            broadcast.selectMode('broadcaster');
        });
    </script>
</body>
</html>
